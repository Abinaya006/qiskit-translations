

<!DOCTYPE html>
<html class="writer-html5" lang="pt-BR" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Qiskit Gradient Framework &mdash; documentação Qiskit 0.23.0</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinx_tabs/tabs.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme-override.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="../../_static/translations.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0-alpha.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Buscar" href="../../search.html" />
    <script>
    (function () {
      'use strict'
      window._analytics = {
        segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw',
        coremetrics: false,
        optimizely: false,
        googleAddServices: false,
        fullStory: false,
        autoPageEventSpa: false,
        autoFormEvents: false,
        autoPageView: false
      }

      window.digitalData = {
        page: {
          pageInfo: {
            productTitle: 'IBM Q Experience',
            analytics: {
              category: 'Qiskit.org'
            }
          }
        }
      }

      window._analyticsReady = window._analyticsReady || new Promise((resolve) => {
        const script = document.createElement('script')
        script.async = true
        script.src = 'https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js'
        document.head.appendChild(script)
        script.onload = resolve
        script.onerror = (err) => {
          console.warn('Error loading Bluemix Analytics script:', err)
          resolve()
        }
      })

      window._analyticsReady.then(() => {
        if (!window.bluemixAnalytics || !window.digitalData) { return }

        const category = window.digitalData.page.pageInfo.analytics.category
        const productTitle = window.digitalData.page.pageInfo.productTitle
        const routeName = 'api-documentation'

        window.bluemixAnalytics.pageEvent(category, routeName, {
          navigationType: 'pushState',
          productTitle: productTitle,
          title: document.title
        })
      })
    }());
    </script>
     

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #212121" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Qiskit
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Instalando o Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Primeiros passos com Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../the_elements.html">Os Elementos Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development_strategy.html">Estratégia de Desenvolvimento</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing_to_qiskit.html">Contribuindo para o Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Notas da Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuração local</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Perguntas Frequentes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutoriais</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../circuits/index.html">Circuitos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../circuits_advanced/index.html">Circuitos Avançados</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pulse/index.html">Pulso</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simulators/index.html">Simuladores de Alto Desempenho</a></li>
<li class="toctree-l1"><a class="reference internal" href="../noise/index.html">Análise de Erros do Sistema Quântico</a></li>
<li class="toctree-l1"><a class="reference internal" href="../optimization/index.html">Otimização</a></li>
<li class="toctree-l1"><a class="reference internal" href="../finance/index.html">Finanças</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chemistry/index.html">Química</a></li>
</ul>
<p class="caption"><span class="caption-text">Bibliotecas</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/circuit_library.html">Biblioteca de Circuitos</a></li>
</ul>
<p class="caption"><span class="caption-text">Referências de API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/terra.html">Qiskit Terra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/aer.html">Qiskit Aer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/ignis.html">Qiskit Ignis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/aqua.html">Qiskit Aqua</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/ibmq-provider.html">Qiskit IBM Provedor Quântico</a></li>
</ul>
<p class="caption"><span class="caption-text">Solução de problemas</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://quantum-computing.ibm.com/docs/cloud/errors">Códigos de erro da API do Quantum Experience</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Qiskit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Qiskit Gradient Framework</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/tutorials/operators/02_gradients_framework.ipynb" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>This page was generated from <a class="reference external" href="https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/operators/02_gradients_framework.ipynb">tutorials/operators/02_gradients_framework.ipynb</a>.</p>
</div>
<div class="section" id="Qiskit-Gradient-Framework">
<h1>Qiskit Gradient Framework<a class="headerlink" href="#Qiskit-Gradient-Framework" title="Link permanente para este título">¶</a></h1>
<p>The gradient framework enables the evaluation of quantum gradients as well as functions thereof. Besides standard first order gradients of expectation values of the form</p>
<div class="math notranslate nohighlight">
\[\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle\]</div>
<p>The gradient framework also supports the evaluation of second order gradients (Hessians), and the Quantum Fisher Information (QFI) of quantum states <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span>.</p>
<div class="section" id="Table-of-Contents">
<h2>Table of Contents<a class="headerlink" href="#Table-of-Contents" title="Link permanente para este título">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="#grad">First Order Gradients</a></p></li>
<li><p><a class="reference external" href="#grad_meas">Gradients w.r.t. Measurement Operator Parameters</a></p></li>
<li><p><a class="reference external" href="#grad_state">Gradients w.r.t. State Parameters</a></p></li>
<li><p><a class="reference external" href="#nat_grad">Natural Gradient</a></p></li>
<li><p><a class="reference external" href="#hess">Hessians</a></p></li>
<li><p><a class="reference external" href="#hess_meas">Hessians w.r.t. Measurement Operator Parameters</a></p></li>
<li><p><a class="reference external" href="#hess_state">Hessians w.r.t. State Parameters</a></p></li>
<li><p><a class="reference external" href="#qfi">Quantum Fisher Information</a></p></li>
<li><p><a class="reference external" href="#apps">Application Example: VQE with gradient-based optimization</a></p></li>
</ol>
<p><a href="#id2"><span class="problematic" id="id3">|gradient\_framework.png|</span></a></p>
<div class="section" id="Imports">
<h3>Imports<a class="headerlink" href="#Imports" title="Link permanente para este título">¶</a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1">#General imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1">#Operator Imports</span>
<span class="kn">from</span> <span class="nn">qiskit.aqua.operators</span> <span class="kn">import</span> <span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">StateFn</span><span class="p">,</span> <span class="n">CircuitStateFn</span><span class="p">,</span> <span class="n">SummedOp</span>
<span class="kn">from</span> <span class="nn">qiskit.aqua.operators.gradients</span> <span class="kn">import</span> <span class="n">Gradient</span><span class="p">,</span> <span class="n">NaturalGradient</span><span class="p">,</span> <span class="n">QFI</span><span class="p">,</span> <span class="n">Hessian</span>

<span class="c1">#Circuit imports</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">ParameterVector</span><span class="p">,</span> <span class="n">ParameterExpression</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">EfficientSU2</span>
</pre></div>
</div>
</div>
<blockquote>
<div><p>First Order Gradients</p>
</div></blockquote>
<hr class="docutils" />
<p>Given a parameterized quantum state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle = V\left(\theta\right)|\psi\rangle\)</span> with input state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, parametrized Ansatz <span class="math notranslate nohighlight">\(V\left(\theta\right)\)</span>, and observable <span class="math notranslate nohighlight">\(\hat{O}\left(\omega\right)=\sum_{i}\omega_i\hat{O}_i\)</span>, we want to compute…</p>
<blockquote>
<div><p>Gradients w.r.t. Measurement Operator Parameters</p>
</div></blockquote>
<hr class="docutils" />
<p>Gradient of an expectation value w.r.t. a coefficient of the measurement operator respectively observable <span class="math notranslate nohighlight">\(\hat{O}\left(\omega\right)\)</span>, i.e.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\omega_i} = \langle\psi\left(\theta\right)|\hat{O}_i\left(\omega\right)|\psi\left(\theta\right)\rangle.\]</div>
<p>First of all, we define a quantum state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span> and a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> acting as observable. Then, the state and the Hamiltonian are wrapped into an object defining the expectation value</p>
<div class="math notranslate nohighlight">
\[\langle\psi\left(\theta\right)|H|\psi\left(\theta\right)\rangle.\]</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Instantiate the quantum state</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Instantiate the Hamiltonian observable</span>
<span class="n">coeff_0</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;c_0&#39;</span><span class="p">)</span>
<span class="n">coeff_1</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;c_1&#39;</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">coeff_0</span><span class="o">*</span><span class="n">coeff_0</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">coeff_1</span> <span class="o">*</span> <span class="n">Z</span>

<span class="c1"># Combine the Hamiltonian observable and the state</span>
<span class="n">op</span> <span class="o">=</span> <span class="o">~</span><span class="n">StateFn</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">@</span> <span class="n">CircuitStateFn</span><span class="p">(</span><span class="n">primitive</span><span class="o">=</span><span class="n">qc</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

<span class="c1"># Print the operator corresponding to the expectation value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ComposedOp([
  OperatorMeasurement(SummedOp([
    2.0*c_0**2 * X,
    1.0*c_1 * Z
  ])),
  CircuitStateFn(
        ┌───┐┌───────┐┌───────┐
  q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b) ├
        └───┘└───────┘└───────┘
  )
])
</pre></div></div>
</div>
<p>We construct a list of the parameters for which we aim to evaluate the gradient. In this case, the parameters are given as the coefficients of <span class="math notranslate nohighlight">\(H\)</span>. Now, this list and the expectation value operator are used to generate the operator which represents the gradient.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Define the coefficients w.r.t. we want to compute the gradient</span>
<span class="n">obs_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff_0</span><span class="p">,</span> <span class="n">coeff_1</span><span class="p">]</span>

<span class="c1"># Define the values to be assigned to the parameters</span>
<span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">coeff_0</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">coeff_1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">}</span>

<span class="c1"># Convert the operator and the gradient target coefficients into the respective operator</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">Gradient</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span> <span class="o">=</span> <span class="n">op</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">obs_coeffs</span><span class="p">)</span>

<span class="c1"># Print the operator corresponding to the Gradient</span>
<span class="nb">print</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ListOp([
  4.0*c_0 * ComposedOp([
    OperatorMeasurement(1.00000000000000 * Z),
    CircuitStateFn(
          ┌───┐┌───────┐┌───────┐┌───┐
    q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b) ├┤ H ├
          └───┘└───────┘└───────┘└───┘
    )
  ]),
  1.00000000000000 * ComposedOp([
    OperatorMeasurement(1.00000000000000 * Z),
    CircuitStateFn(
          ┌───┐┌───────┐┌───────┐
    q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b) ├
          └───┘└───────┘└───────┘
    )
  ])
])
</pre></div></div>
</div>
<p>All that is left to do is to assign values to the pararameters and to evaluate the gradient operators.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Assign the parameters and evaluate the gradient</span>
<span class="n">grad_result</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gradient&#39;</span><span class="p">,</span> <span class="n">grad_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Gradient [(1.414213562373095+1.12e-16j), 0j]
</pre></div></div>
</div>
<blockquote>
<div><p>Gradients w.r.t. State Parameters</p>
</div></blockquote>
<hr class="docutils" />
<p>Gradient of an expectation value w.r.t. a state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span> parameter, i.e.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\frac{\partial\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta}\\respectively of sampling probabilities w.r.t. a state :math:`|\psi\left(\theta\right)\rangle` parameter, i.e.\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\frac{\partial p_i}{\partial\theta} = \frac{\partial\langle\psi\left(\theta\right)|i\rangle\langle i |\psi\left(\theta\right)\rangle}{\partial\theta}.\\A gradient w.r.t. a state parameter may be evaluated with different methods. Each method has advantages and disadvantages.\end{aligned}\end{align} \]</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Define the Hamiltonian with fixed coefficients</span>
<span class="n">H</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">X</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">Z</span>
<span class="c1"># Define the parameters w.r.t. we want to compute the gradients</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
<span class="c1"># Define the values to be assigned to the parameters</span>
<span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">}</span>

<span class="c1"># Combine the Hamiltonian observable and the state into an expectation value operator</span>
<span class="n">op</span> <span class="o">=</span> <span class="o">~</span><span class="n">StateFn</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">@</span> <span class="n">CircuitStateFn</span><span class="p">(</span><span class="n">primitive</span><span class="o">=</span><span class="n">qc</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ComposedOp([
  OperatorMeasurement(SummedOp([
    0.5 * X,
    -1.0 * Z
  ])),
  CircuitStateFn(
        ┌───┐┌───────┐┌───────┐
  q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b) ├
        └───┘└───────┘└───────┘
  )
])
</pre></div></div>
</div>
<div class="section" id="Parameter-Shift-Gradients">
<h4>Parameter Shift Gradients<a class="headerlink" href="#Parameter-Shift-Gradients" title="Link permanente para este título">¶</a></h4>
<blockquote>
<div><p>Given a Hermitian operator <span class="math notranslate nohighlight">\(g\)</span> with two unique eigenvalues <span class="math notranslate nohighlight">\(\pm r\)</span> which acts as generator for a parameterized quantum gate</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}G(\theta)= e^{-i\theta g}.\\Then, quantum gradients can be computed by using eigenvalue :math:`r` dependent shifts to parameters. All `standard, parameterized Qiskit gates &lt;https://github.com/Qiskit/qiskit-terra/tree/master/qiskit/circuit/library/standard_gates&gt;`__ can be shifted with :math:`\pi/2`, i.e.,\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\frac{\partial\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta} =  \left(\langle\psi\left(\theta+\pi/2\right)|\hat{O}\left(\omega\right)|\psi\left(\theta+\pi/2\right)\rangle -\partial\langle\psi\left(\theta-\pi/2\right)|\hat{O}\left(\omega\right)|\psi\left(\theta-\pi/2\right)\rangle\right) / 2.\\Probability gradients are computed equivalently.\end{aligned}\end{align} \]</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Convert the expectation value into an operator corresponding to the gradient w.r.t. the state parameters using</span>
<span class="c1"># the parameter shift method.</span>
<span class="n">state_grad</span> <span class="o">=</span> <span class="n">Gradient</span><span class="p">(</span><span class="n">grad_method</span><span class="o">=</span><span class="s1">&#39;param_shift&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="c1"># Print the operator corresponding to the gradient</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state_grad</span><span class="p">)</span>
<span class="c1"># Assign the parameters and evaluate the gradient</span>
<span class="n">state_grad_result</span> <span class="o">=</span> <span class="n">state_grad</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;State gradient computed with parameter shift&#39;</span><span class="p">,</span> <span class="n">state_grad_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ListOp([
  SummedOp([
    0.25 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌─────────────────────────┐┌───────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a + 1.5707963267949) ├┤ RX(b) ├┤ H ├
            └───┘└─────────────────────────┘└───────┘└───┘
      )
    ]),
    -0.25 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌─────────────────────────┐┌───────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a - 1.5707963267949) ├┤ RX(b) ├┤ H ├
            └───┘└─────────────────────────┘└───────┘└───┘
      )
    ]),
    -0.5 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌─────────────────────────┐┌───────┐
      q0_0: ┤ H ├┤ RZ(a + 1.5707963267949) ├┤ RX(b) ├
            └───┘└─────────────────────────┘└───────┘
      )
    ]),
    0.5 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌─────────────────────────┐┌───────┐
      q0_0: ┤ H ├┤ RZ(a - 1.5707963267949) ├┤ RX(b) ├
            └───┘└─────────────────────────┘└───────┘
      )
    ])
  ]),
  SummedOp([
    0.25 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌─────────────────────────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b + 1.5707963267949) ├┤ H ├
            └───┘└───────┘└─────────────────────────┘└───┘
      )
    ]),
    -0.25 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌─────────────────────────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b - 1.5707963267949) ├┤ H ├
            └───┘└───────┘└─────────────────────────┘└───┘
      )
    ]),
    -0.5 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌─────────────────────────┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b + 1.5707963267949) ├
            └───┘└───────┘└─────────────────────────┘
      )
    ]),
    0.5 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌─────────────────────────┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b - 1.5707963267949) ├
            └───┘└───────┘└─────────────────────────┘
      )
    ])
  ])
])
State gradient computed with parameter shift [(-0.35355339059327373-4.175e-17j), (0.7071067811865475+4.15e-17j)]
</pre></div></div>
</div>
<p>#### Linear Combination of Unitaries Gradients Unitaries can be written as <span class="math notranslate nohighlight">\(U\left(\omega\right) = e^{iM\left(\omega\right)}\)</span>, where <span class="math notranslate nohighlight">\(M\left(\omega\right)\)</span> denotes a parameterized Hermitian matrix. Further, Hermitian matrices can be decomposed into weighted sums of Pauli terms, i.e., <span class="math notranslate nohighlight">\(M\left(\omega\right) = \sum_pm_p\left(\omega\right)h_p\)</span> with <span class="math notranslate nohighlight">\(m_p\left(\omega\right)\in\mathbb{R}\)</span> and <span class="math notranslate nohighlight">\(h_p=\bigotimes\limits_{j=0}^{n-1}\sigma_{j, p}\)</span> for
<span class="math notranslate nohighlight">\(\sigma_{j, p}\in\left\{I, X, Y, Z\right\}\)</span> acting on the <span class="math notranslate nohighlight">\(j^{\text{th}}\)</span> qubit. Thus, the gradients of <span class="math notranslate nohighlight">\(U_k\left(\omega_k\right)\)</span> are given by</p>
<div class="math notranslate nohighlight">
\begin{equation*}
\frac{\partial U_k\left(\omega_k\right)}{\partial\omega_k} = \sum\limits_pi \frac{\partial m_{k,p}\left(\omega_k\right)}{\partial\omega_k}U_k\left(\omega_k\right)h_{k_p}.
\end{equation*}</div><p>Combining this observation with a circuit structure presented in <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.65.042323">Simulating physical phenomena by quantum networks</a> allows us to compute the gradient with the evaluation of a single quantum circuit.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Convert the expectation value into an operator corresponding to the gradient w.r.t. the state parameter using</span>
<span class="c1"># the linear combination of unitaries method.</span>
<span class="n">state_grad</span> <span class="o">=</span> <span class="n">Gradient</span><span class="p">(</span><span class="n">grad_method</span><span class="o">=</span><span class="s1">&#39;lin_comb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># Print the operator corresponding to the gradient</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state_grad</span><span class="p">)</span>

<span class="c1"># Assign the parameters and evaluate the gradient</span>
<span class="n">state_grad_result</span> <span class="o">=</span> <span class="n">state_grad</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;State gradient computed with the linear combination method&#39;</span><span class="p">,</span> <span class="n">state_grad_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ListOp([
  SummedOp([
    0.5 * ComposedOp([
      OperatorMeasurement(ZZ) * 2.0,
      CircuitStateFn(
                                  ┌───┐          ┌───────┐┌───────┐┌───┐
                            q0_0: ┤ H ├────────■─┤ RZ(a) ├┤ RX(b) ├┤ H ├
                                  ├───┤┌─────┐ │ └─┬───┬─┘└───────┘└───┘
      work_qubit_lin_comb_grad_0: ┤ H ├┤ SDG ├─■───┤ H ├────────────────
                                  └───┘└─────┘     └───┘
      ) * 0.7071067811865476
    ]),
    -1.0 * ComposedOp([
      OperatorMeasurement(ZZ) * 2.0,
      CircuitStateFn(
                                  ┌───┐          ┌───────┐┌───────┐
                            q0_0: ┤ H ├────────■─┤ RZ(a) ├┤ RX(b) ├
                                  ├───┤┌─────┐ │ └─┬───┬─┘└───────┘
      work_qubit_lin_comb_grad_0: ┤ H ├┤ SDG ├─■───┤ H ├───────────
                                  └───┘└─────┘     └───┘
      ) * 0.7071067811865476
    ])
  ]),
  SummedOp([
    0.5 * ComposedOp([
      OperatorMeasurement(ZZ) * 2.0,
      CircuitStateFn(
                                  ┌───┐┌───────┐┌───┐┌───────┐┌───┐
                            q0_0: ┤ H ├┤ RZ(a) ├┤ X ├┤ RX(b) ├┤ H ├
                                  ├───┤└┬─────┬┘└─┬─┘└─┬───┬─┘└───┘
      work_qubit_lin_comb_grad_0: ┤ H ├─┤ SDG ├───■────┤ H ├───────
                                  └───┘ └─────┘        └───┘
      ) * 0.7071067811865476
    ]),
    -1.0 * ComposedOp([
      OperatorMeasurement(ZZ) * 2.0,
      CircuitStateFn(
                                  ┌───┐┌───────┐┌───┐┌───────┐
                            q0_0: ┤ H ├┤ RZ(a) ├┤ X ├┤ RX(b) ├
                                  ├───┤└┬─────┬┘└─┬─┘└─┬───┬─┘
      work_qubit_lin_comb_grad_0: ┤ H ├─┤ SDG ├───■────┤ H ├──
                                  └───┘ └─────┘        └───┘
      ) * 0.7071067811865476
    ])
  ])
])
State gradient computed with the linear combination method [(-0.3535533905932738-2.39e-16j), (0.7071067811865476+1.64e-16j)]
</pre></div></div>
</div>
<p>#### Finite Difference Gradients</p>
<p>Unlike the other methods, finite difference gradients are numerical estimations rather than analytical values. This implementation employs a central difference approach with <span class="math notranslate nohighlight">\(\epsilon &lt;&lt; 1\)</span> $ <span class="math">\frac{\partial\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta}</span> <span class="math">\approx `:nbsphinx-math:</span>frac{1}{2epsilon}`
<span class="math">\left`(:nbsphinx-math:</span>langle`:nbsphinx-math:<cite>psi</cite><span class="math">\left`(:nbsphinx-math:</span>theta`+:nbsphinx-math:<cite>epsilon</cite><span class="math">\right</span>)|:nbsphinx-math:<cite>hat{O}</cite><span class="math">\left`(:nbsphinx-math:</span>omega`:nbsphinx-math:<cite>right</cite>)|:nbsphinx-math:<cite>psi</cite><span class="math">\left`(:nbsphinx-math:</span>theta`+:nbsphinx-math:<cite>epsilon</cite><span class="math">\right</span>):nbsphinx-math:<cite>rangle `-
:nbsphinx-math:</cite>partial`:nbsphinx-math:<cite>langle</cite><span class="math">\psi</span><span class="math">\left`(:nbsphinx-math:</span>theta`-<span class="math">\epsilon</span><span class="math">\right</span>)|:nbsphinx-math:<cite>hat{O}</cite><span class="math">\left`(:nbsphinx-math:</span>omega`:nbsphinx-math:<cite>right</cite>)|:nbsphinx-math:<cite>psi</cite><span class="math">\left`(:nbsphinx-math:</span>theta`-<span class="math">\epsilon</span><span class="math">\right</span>):nbsphinx-math:<cite>rangle</cite><span class="math">\right</span>).$ Probability gradients are computed equivalently.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Convert the expectation value into an operator corresponding to the gradient w.r.t. the state parameter using</span>
<span class="c1"># the finite difference method.</span>
<span class="n">state_grad</span> <span class="o">=</span> <span class="n">Gradient</span><span class="p">(</span><span class="n">grad_method</span><span class="o">=</span><span class="s1">&#39;fin_diff&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># Print the operator corresponding to the gradient</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state_grad</span><span class="p">)</span>

<span class="c1"># Assign the parameters and evaluate the gradient</span>
<span class="n">state_grad_result</span> <span class="o">=</span> <span class="n">state_grad</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;State gradient computed with finite difference&#39;</span><span class="p">,</span> <span class="n">state_grad_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ListOp([
  SummedOp([
    250000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌────────────────┐┌───────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a + 1.0e-6) ├┤ RX(b) ├┤ H ├
            └───┘└────────────────┘└───────┘└───┘
      )
    ]),
    -250000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌────────────────┐┌───────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a - 1.0e-6) ├┤ RX(b) ├┤ H ├
            └───┘└────────────────┘└───────┘└───┘
      )
    ]),
    -500000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌────────────────┐┌───────┐
      q0_0: ┤ H ├┤ RZ(a + 1.0e-6) ├┤ RX(b) ├
            └───┘└────────────────┘└───────┘
      )
    ]),
    500000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌────────────────┐┌───────┐
      q0_0: ┤ H ├┤ RZ(a - 1.0e-6) ├┤ RX(b) ├
            └───┘└────────────────┘└───────┘
      )
    ])
  ]),
  SummedOp([
    250000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌────────────────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b + 1.0e-6) ├┤ H ├
            └───┘└───────┘└────────────────┘└───┘
      )
    ]),
    -250000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌────────────────┐┌───┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b - 1.0e-6) ├┤ H ├
            └───┘└───────┘└────────────────┘└───┘
      )
    ]),
    -500000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌────────────────┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b + 1.0e-6) ├
            └───┘└───────┘└────────────────┘
      )
    ]),
    500000.0 * ComposedOp([
      OperatorMeasurement(Z),
      CircuitStateFn(
            ┌───┐┌───────┐┌────────────────┐
      q0_0: ┤ H ├┤ RZ(a) ├┤ RX(b - 1.0e-6) ├
            └───┘└───────┘└────────────────┘
      )
    ])
  ])
])
State gradient computed with finite difference [(-0.3535533905669581-2.775e-11j), (0.7071067812098961+2.7749999999999998e-11j)]
</pre></div></div>
</div>
<blockquote>
<div><p>Natural Gradient</p>
</div></blockquote>
<hr class="docutils" />
<p>A special type of first order gradient is the natural gradient which has proven itself useful in classical machine learning and is already being studied in the quantum context. This quantity represents a gradient that is ‘rescaled’ with the inverse <a class="reference external" href="#qfi">Quantum Fisher Information matrix</a> (QFI)</p>
<div class="math notranslate nohighlight">
\[QFI ^{-1} \frac{\partial\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta}.\]</div>
<p>Instead of inverting the QFI, one can also use a least-square solver with or without regularization to solve</p>
<div class="math notranslate nohighlight">
\[QFI x = \frac{\partial\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta}.\]</div>
<p>The implementation supports ridge and lasso regularization with automatic search for a good parameter using <a class="reference external" href="https://arxiv.org/pdf/1608.04571.pdf">L-curve corner search</a> as well as two types of perturbations of the diagonal elements of the QFI.</p>
<p>The natural gradient can be used instead of the standard gradient with any gradient-based optimizer and/or ODE solver.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Besides the method to compute the circuit gradients resp. QFI, a regularization method can be chosen:</span>
<span class="c1"># `ridge` or `lasso` with automatic parameter search or `perturb_diag_elements` or `perturb_diag`</span>
<span class="c1"># which perturb the diagonal elements of the QFI.</span>
<span class="n">nat_grad</span> <span class="o">=</span> <span class="n">NaturalGradient</span><span class="p">(</span><span class="n">grad_method</span><span class="o">=</span><span class="s1">&#39;lin_comb&#39;</span><span class="p">,</span> <span class="n">qfi_method</span><span class="o">=</span><span class="s1">&#39;lin_comb_full&#39;</span><span class="p">,</span> <span class="n">regularization</span><span class="o">=</span><span class="s1">&#39;ridge&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
                           <span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># Assign the parameters and evaluate the gradient</span>
<span class="n">nat_grad_result</span> <span class="o">=</span> <span class="n">nat_grad</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Natural gradient computed with linear combination of unitaries&#39;</span><span class="p">,</span> <span class="n">nat_grad_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Natural gradient computed with linear combination of unitaries [-2.17412662  1.90236079]
</pre></div></div>
</div>
<blockquote>
<div><p>Hessians (Second Order Gradients)</p>
</div></blockquote>
<hr class="docutils" />
<p>Four types of second order gradients are supported by the gradient framework. 1. Gradient of an expectation value w.r.t. a coefficient of the measurement operator respectively observable <span class="math notranslate nohighlight">\(\hat{O}\left(\omega\right)\)</span>, i.e. $ <span class="math">\frac{\partial^2\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\omega^2}</span> $ 2. Gradient of an expectation value w.r.t. a state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span> parameter, i.e. $
<span class="math">\frac{\partial^2\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta^2}</span> $ 3. Gradient of sampling probabilities w.r.t. a state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span> parameter, i.e. $ <span class="math">\frac{\partial^2 p_i}{\partial\theta^2}</span> = <span class="math">\frac{\partial^2\langle\psi\left(\theta\right)|i\rangle\langle i|\psi\left(\theta\right)\rangle}{\partial\theta^2}</span> $ 4. Gradient of an expectation value w.r.t. a state
<span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span> parameter and a coefficient of the measurement operator respectively observable <span class="math notranslate nohighlight">\(\hat{O}\left(\omega\right)\)</span>, i.e. $ <span class="math">\frac{\partial^2\langle\psi\left(\theta\right)|\hat{O}\left(\omega\right)|\psi\left(\theta\right)\rangle}{\partial\theta\partial\omega}</span> $</p>
<p>In the following examples are given for the first two Hessian types. The remainig Hessians are evaluated analogously.</p>
<blockquote>
<div><p>Hessians w.r.t. Measurement Operator Parameters</p>
</div></blockquote>
<hr class="docutils" />
<p>Again, we define a quantum state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle\)</span> and a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> acting as observable. Then, the state and the Hamiltonian are wrapped into an object defining the expectation value</p>
<div class="math notranslate nohighlight">
\[\langle\psi\left(\theta\right)|H|\psi\left(\theta\right)\rangle.\]</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Instantiate the Hamiltonian observable</span>
<span class="n">coeff_0</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;c_0&#39;</span><span class="p">)</span>
<span class="n">coeff_1</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;c_1&#39;</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">coeff_0</span><span class="o">*</span><span class="n">coeff_1</span><span class="o">*</span><span class="n">coeff_1</span><span class="o">*</span><span class="n">X</span>

<span class="c1"># Instantiate the quantum state with two parameters</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Combine the Hamiltonian observable and the state</span>
<span class="n">op</span> <span class="o">=</span> <span class="o">~</span><span class="n">StateFn</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">@</span> <span class="n">CircuitStateFn</span><span class="p">(</span><span class="n">primitive</span><span class="o">=</span><span class="n">qc</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Next, we can choose the parameters for which we want to compute second order gradients. - Given a tuple, the <code class="docutils literal notranslate"><span class="pre">Hessian</span></code> will evaluate the second order gradient for the two parameters. - Given a list, the <code class="docutils literal notranslate"><span class="pre">Hessian</span></code> will evaluate the second order gradient for all possible combinations of tuples of these parameters.</p>
<p>After binding parameter values to the parameters, the Hessian can be evaluated.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Define the coefficient tuple w.r.t. which we want to compute the gradient</span>
<span class="n">hessian_coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">coeff_0</span><span class="p">,</span> <span class="n">coeff_1</span><span class="p">)</span>

<span class="c1"># Convert the operator and the hessian target coefficients into the respective operator</span>
<span class="n">hessian</span> <span class="o">=</span> <span class="n">Hessian</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span> <span class="o">=</span> <span class="n">op</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff_0</span><span class="p">,</span> <span class="n">coeff_1</span><span class="p">])</span>

<span class="c1"># Define the values to be assigned to the parameters</span>
<span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">coeff_0</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">coeff_1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">}</span>

<span class="c1"># Assign the parameters and evaluate the Hessian w.r.t. the Hamiltonian coefficients</span>
<span class="n">hessian_result</span> <span class="o">=</span> <span class="n">hessian</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hessian </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hessian_result</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hessian
 [[ 0.         -1.41421356]
 [-1.41421356  0.70710678]]
</pre></div></div>
</div>
<blockquote>
<div><p>Hessians w.r.t. State Parameters</p>
</div></blockquote>
<hr class="docutils" />
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Define parameters</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>

<span class="c1"># Get the operator object representing the Hessian</span>
<span class="n">state_hess</span> <span class="o">=</span> <span class="n">Hessian</span><span class="p">(</span><span class="n">hess_method</span><span class="o">=</span><span class="s1">&#39;param_shift&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="c1"># Assign the parameters and evaluate the Hessian</span>
<span class="n">hessian_result</span> <span class="o">=</span> <span class="n">state_hess</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hessian computed using the parameter shift method</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hessian_result</span><span class="p">)))</span>

<span class="c1"># Get the operator object representing the Hessian</span>
<span class="n">state_hess</span> <span class="o">=</span> <span class="n">Hessian</span><span class="p">(</span><span class="n">hess_method</span><span class="o">=</span><span class="s1">&#39;lin_comb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="c1"># Assign the parameters and evaluate the Hessian</span>
<span class="n">hessian_result</span> <span class="o">=</span> <span class="n">state_hess</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hessian computed using the linear combination of unitaries method</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hessian_result</span><span class="p">)))</span>

<span class="c1"># Get the operator object representing the Hessian using finite difference</span>
<span class="n">state_hess</span> <span class="o">=</span> <span class="n">Hessian</span><span class="p">(</span><span class="n">hess_method</span><span class="o">=</span><span class="s1">&#39;fin_diff&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="c1"># Assign the parameters and evaluate the Hessian</span>
<span class="n">hessian_result</span> <span class="o">=</span> <span class="n">state_hess</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hessian computed with finite difference</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hessian_result</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hessian computed using the parameter shift method
 [[-3.53553391e-01-7.6375e-17j  6.93889390e-17-1.4000e-17j]
 [ 8.32667268e-17-1.4000e-17j  0.00000000e+00+2.7750e-17j]]
Hessian computed using the linear combination of unitaries method
 [[-0.35355339-4.82e-16j  0.        +0.00e+00j]
 [ 0.        +0.00e+00j  0.        +0.00e+00j]]
Hessian computed with finite difference
 [[-3.53546143e-01+7.0000e-06j  1.52587891e-05+1.3750e-05j]
 [ 1.52587891e-05+1.3750e-05j  4.57763672e-05+2.0875e-05j]]
</pre></div></div>
</div>
<blockquote>
<div><p>Quantum Fisher Information (QFI)</p>
</div></blockquote>
<hr class="docutils" />
<p>The Quantum Fisher Information is a metric tensor which is representative for the representation capacity of a parameterized quantum state <span class="math notranslate nohighlight">\(|\psi\left(\theta\right)\rangle = V\left(\theta\right)|\psi\rangle\)</span> with input state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, parametrized Ansatz <span class="math notranslate nohighlight">\(V\left(\theta\right)\)</span>.</p>
<p>The entries of the QFI for a pure state reads</p>
<div class="math notranslate nohighlight">
\[QFI_{kl} = 4 * \text{Re}\left[\langle\partial_k\psi|\partial_l\psi\rangle-\langle\partial_k\psi|\psi\rangle\langle\psi|\partial_l\psi\rangle \right].\]</div>
</div>
</div>
<div class="section" id="Circuit-QFIs">
<h3>Circuit QFIs<a class="headerlink" href="#Circuit-QFIs" title="Link permanente para este título">¶</a></h3>
<p>The evaluation of the QFI corresponding to a quantum state that is generated by a parameterized quantum circuit can be conducted in different ways.</p>
<div class="section" id="Linear-Combination-Full-QFI">
<h4>Linear Combination Full QFI<a class="headerlink" href="#Linear-Combination-Full-QFI" title="Link permanente para este título">¶</a></h4>
<p>To compute the full QFI, we use a working qubit as well as intercepting controlled gates. See e.g. <a class="reference external" href="https://www.nature.com/articles/s41534-019-0187-2">Variational ansatz-based quantum simulation of imaginary time evolution</a>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Wrap the quantum circuit into a CircuitStateFn</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">CircuitStateFn</span><span class="p">(</span><span class="n">primitive</span><span class="o">=</span><span class="n">qc</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

<span class="c1"># Convert the state and the parameters into the operator object that represents the QFI</span>
<span class="n">qfi</span> <span class="o">=</span> <span class="n">QFI</span><span class="p">(</span><span class="n">qfi_method</span><span class="o">=</span><span class="s1">&#39;lin_comb_full&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="c1"># Define the values for which the QFI is to be computed</span>
<span class="n">values_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">}</span>

<span class="c1"># Assign the parameters and evaluate the QFI</span>
<span class="n">qfi_result</span> <span class="o">=</span> <span class="n">qfi</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">values_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;full QFI </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qfi_result</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
full QFI
 [[ 1.00000000e+00 -1.97989899e-17]
 [-1.97989899e-17  5.00000000e-01]]
</pre></div></div>
</div>
</div>
<div class="section" id="Block-diagonal-and-Diagonal-Approximation">
<h4>Block-diagonal and Diagonal Approximation<a class="headerlink" href="#Block-diagonal-and-Diagonal-Approximation" title="Link permanente para este título">¶</a></h4>
<p>A block-diagonal resp. diagonal approximation of the QFI can be computed without additional working qubits. This implementation requires the unrolling into Pauli rotations and unparameterized Gates.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Convert the state and the parameters into the operator object that represents the QFI</span>
<span class="c1"># and set the approximation to &#39;block_diagonal&#39;</span>
<span class="n">qfi</span> <span class="o">=</span> <span class="n">QFI</span><span class="p">(</span><span class="s1">&#39;overlap_block_diag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># Assign the parameters and evaluate the QFI</span>
<span class="n">qfi_result</span> <span class="o">=</span> <span class="n">qfi</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">values_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Block-diagonal QFI </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qfi_result</span><span class="p">)))</span>

<span class="c1"># Convert the state and the parameters into the operator object that represents the QFI</span>
<span class="c1"># and set the approximation to &#39;diagonal&#39;</span>
<span class="n">qfi</span> <span class="o">=</span> <span class="n">QFI</span><span class="p">(</span><span class="s1">&#39;overlap_diag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># Assign the parameters and evaluate the QFI</span>
<span class="n">qfi_result</span> <span class="o">=</span> <span class="n">qfi</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">values_dict</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Diagonal QFI </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qfi_result</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Block-diagonal QFI
 [[1.  0. ]
 [0.  0.5]]
Diagonal QFI
 [[1.  0. ]
 [0.  0.5]]
</pre></div></div>
</div>
<blockquote>
<div><p>Application Example: VQE with gradient-based optimization</p>
</div></blockquote>
<hr class="docutils" />
</div>
</div>
<div class="section" id="Additional-Imports">
<h3>Additional Imports<a class="headerlink" href="#Additional-Imports" title="Link permanente para este título">¶</a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Execution Imports</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span>
<span class="kn">from</span> <span class="nn">qiskit.aqua</span> <span class="kn">import</span> <span class="n">QuantumInstance</span>

<span class="c1"># Algorithm Imports</span>
<span class="kn">from</span> <span class="nn">qiskit.aqua.algorithms</span> <span class="kn">import</span> <span class="n">VQE</span>
<span class="kn">from</span> <span class="nn">qiskit.aqua.components.optimizers</span> <span class="kn">import</span> <span class="n">CG</span>
</pre></div>
</div>
</div>
<p>The Gradient Framework can also be used for a gradient-based <code class="docutils literal notranslate"><span class="pre">VQE</span></code>. First, the Hamiltonian and wavefunction ansatz are initialized.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">qiskit.aqua.operators</span> <span class="kn">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">ParameterVector</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>

<span class="c1"># Instantiate the system Hamiltonian</span>
<span class="n">h2_hamiltonian</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.05</span> <span class="o">*</span> <span class="p">(</span><span class="n">I</span> <span class="o">^</span> <span class="n">I</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.39</span> <span class="o">*</span> <span class="p">(</span><span class="n">I</span> <span class="o">^</span> <span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.39</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span> <span class="o">^</span> <span class="n">I</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span> <span class="o">^</span> <span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.18</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">^</span> <span class="n">X</span><span class="p">)</span>

<span class="c1"># This is the target energy</span>
<span class="n">h2_energy</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.85727503</span>

<span class="c1"># Define the Ansatz</span>
<span class="n">wavefunction</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">ParameterVector</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">wavefunction</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define the expectation value corresponding to the energy</span>
<span class="n">op</span> <span class="o">=</span> <span class="o">~</span><span class="n">StateFn</span><span class="p">(</span><span class="n">h2_hamiltonian</span><span class="p">)</span> <span class="o">@</span> <span class="n">StateFn</span><span class="p">(</span><span class="n">wavefunction</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Now, we can choose whether the <code class="docutils literal notranslate"><span class="pre">VQE</span></code> should use a <code class="docutils literal notranslate"><span class="pre">Gradient</span></code> or <code class="docutils literal notranslate"><span class="pre">NaturalGradient</span></code>, define a <code class="docutils literal notranslate"><span class="pre">QuantumInstance</span></code> to execute the quantum circuits and run the algorithm.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">grad</span> <span class="o">=</span> <span class="n">Gradient</span><span class="p">(</span><span class="n">grad_method</span><span class="o">=</span><span class="s1">&#39;lin_comb&#39;</span><span class="p">)</span>

<span class="n">qi_sv</span> <span class="o">=</span> <span class="n">QuantumInstance</span><span class="p">(</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;statevector_simulator&#39;</span><span class="p">),</span>
                        <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">seed_simulator</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">seed_transpiler</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">#Conjugate Gradient algorithm</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">CG</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="c1"># Gradient callable</span>
<span class="n">vqe</span> <span class="o">=</span> <span class="n">VQE</span><span class="p">(</span><span class="n">h2_hamiltonian</span><span class="p">,</span> <span class="n">wavefunction</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="n">grad</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">vqe</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qi_sv</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;optimal_value&#39;</span><span class="p">],</span> <span class="s1">&#39;Reference:&#39;</span><span class="p">,</span> <span class="n">h2_energy</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Result: -1.8404998432810227 Reference: -1.85727503
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="o">%</span><span class="k">qiskit_version_table</span>
<span class="o">%</span><span class="k">qiskit_copyright</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.23.0</td></tr><tr><td>Terra</td><td>0.16.0</td></tr><tr><td>Aer</td><td>0.7.0</td></tr><tr><td>Ignis</td><td>0.5.0</td></tr><tr><td>Aqua</td><td>0.8.0</td></tr><tr><td>IBM Q Provider</td><td>0.11.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.4 (default, Aug 13 2019, 15:17:50)
[Clang 4.0.1 (tags/RELEASE_401/final)]</td></tr><tr><td>OS</td><td>Darwin</td></tr><tr><td>CPUs</td><td>6</td></tr><tr><td>Memory (Gb)</td><td>16.0</td></tr><tr><td colspan='2'>Wed Oct 21 16:10:18 2020 CEST</td></tr></table></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div style='width: 100%; background-color:#d5d9e0;padding-left: 10px; padding-bottom: 10px; padding-right: 10px; padding-top: 5px'><h3>This code is a part of Qiskit</h3><p>&copy; Copyright IBM 2017, 2020.</p><p>This code is licensed under the Apache License, Version 2.0. You may<br>obtain a copy of this license in the LICENSE.txt file in the root directory<br> of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.<p>Any modifications or derivative works of this code must retain this<br>copyright notice, and modified files need to carry a notice indicating<br>that they have been altered from the originals.</p></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Qiskit Development Team
      <span class="lastupdated">
        Última atualização em 2020/10/26.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Você está visualizando</span>
    lang: pt_BR
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>Idiomas</dt>
      
        <dd><a class="version" href="/documentation/tutorials/operators/02_gradients_framework.html">English</a></dd>
      
        <dd><a class="version" href="/documentation/locale/ja_JP/tutorials/operators/02_gradients_framework.html">Japanese</a></dd>
      
        <dd><a class="version" href="/documentation/locale/de_DE/tutorials/operators/02_gradients_framework.html">German</a></dd>
      
        <dd><a class="version" href="/documentation/locale/ko_KR/tutorials/operators/02_gradients_framework.html">Korean</a></dd>
      
    </dl>
    
  </div>
  <script>
    jQuery('.version').click((evt) => {
      const hash = window.location.hash
      const complete_url = evt.target.href + hash
      window.location = complete_url
      evt.preventDefault()
    })
  </script>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>