

<!DOCTYPE html>
<html class="writer-html5" lang="pt-BR" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Os Elementos Qiskit &mdash; documentação Qiskit 0.21.0</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/tabs.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme-override.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/thebelab-helper.js"></script>
        <script src="_static/translations.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0-alpha.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Buscar" href="search.html" />
    <link rel="next" title="Development Strategy" href="development_strategy.html" />
    <link rel="prev" title="Primeiros passos com Qiskit" href="getting_started.html" />
    <script>
    (function () {
      'use strict'
      window._analytics = {
        segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw',
        coremetrics: false,
        optimizely: false,
        googleAddServices: false,
        fullStory: false,
        autoPageEventSpa: false,
        autoFormEvents: false,
        autoPageView: false
      }

      window.digitalData = {
        page: {
          pageInfo: {
            productTitle: 'IBM Q Experience',
            analytics: {
              category: 'Qiskit.org'
            }
          }
        }
      }

      window._analyticsReady = window._analyticsReady || new Promise((resolve) => {
        const script = document.createElement('script')
        script.async = true
        script.src = 'https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js'
        document.head.appendChild(script)
        script.onload = resolve
        script.onerror = (err) => {
          console.warn('Error loading Bluemix Analytics script:', err)
          resolve()
        }
      })

      window._analyticsReady.then(() => {
        if (!window.bluemixAnalytics || !window.digitalData) { return }

        const category = window.digitalData.page.pageInfo.analytics.category
        const productTitle = window.digitalData.page.pageInfo.productTitle
        const routeName = 'api-documentation'

        window.bluemixAnalytics.pageEvent(category, routeName, {
          navigationType: 'pushState',
          productTitle: productTitle,
          title: document.title
        })
      })
    }());
    </script>
     

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #212121" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Qiskit
          

          
            
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Instalando o Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Primeiros passos com Qiskit</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Os Elementos Qiskit</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#terra">Terra</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aer">Aer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ignis">Ignis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aqua">Aqua</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="development_strategy.html">Development Strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing_to_qiskit.html">Contribuindo para o Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Notas da Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Perguntas Frequentes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutoriais</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/circuits/index.html">Circuitos</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/circuits_advanced/index.html">Circuitos Avançados</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/pulse/index.html">Pulso</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/simulators/index.html">Simuladores de Alto Desempenho</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/noise/index.html">Análise de Erros do Sistema Quântico</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/optimization/index.html">Otimização</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/finance/index.html">Finanças</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/chemistry/index.html">Química</a></li>
</ul>
<p class="caption"><span class="caption-text">Bibliotecas</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="apidoc/circuit_library.html">Biblioteca de Circuitos</a></li>
</ul>
<p class="caption"><span class="caption-text">Referências de API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="apidoc/terra.html">Qiskit Terra</a></li>
<li class="toctree-l1"><a class="reference internal" href="apidoc/aer.html">Qiskit Aer</a></li>
<li class="toctree-l1"><a class="reference internal" href="apidoc/ignis.html">Qiskit Ignis</a></li>
<li class="toctree-l1"><a class="reference internal" href="apidoc/aqua.html">Qiskit Aqua</a></li>
<li class="toctree-l1"><a class="reference internal" href="apidoc/ibmq-provider.html">Qiskit IBM Provedor Quântico</a></li>
</ul>
<p class="caption"><span class="caption-text">Solução de problemas</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://quantum-computing.ibm.com/docs/cloud/errors">Códigos de erro da API do Quantum Experience</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Qiskit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Os Elementos Qiskit</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/the_elements.rst" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="the-qiskit-elements">
<span id="elements"></span><h1>Os Elementos Qiskit<a class="headerlink" href="#the-qiskit-elements" title="Link permanente para este título">¶</a></h1>
<img alt="The Qiskit framework." src="_images/qiskit-framework.png" />
<div class="section" id="terra">
<span id="id1"></span><h2>Terra<a class="headerlink" href="#terra" title="Link permanente para este título">¶</a></h2>
<p>Terra, o elemento ‘terra’, é a base sobre a qual reside o resto do Qiskit. Terra fornece um alicerce para compor programas quânticos no nível de circuitos e pulsos, para otimizá-los para as restrições de um dispositivo, em particular, e para gerenciar a execução de grupos de experimentos em dispositivos de acesso remoto. Terra define as interfaces para uma experiência de usuário final desejável, bem como, a manipulação eficiente de camadas de otimização, planejamento de pulso e comunicação de backend.</p>
<p>O Qiskit Terra é organizado em seis módulos principais:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="apidoc/circuit.html#module-qiskit.circuit" title="qiskit.circuit"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.circuit</span></code></a> Um circuito quântico é um modelo para computação quântica em que um cálculo é feito realizando uma sequência de operações quânticas (geralmente portões) em um registro de qubits. Um circuito quântico geralmente começa com os qubits em um estado <span class="math notranslate nohighlight">\(|0,…,0&gt;\)</span> e esses portões alteram os qubits para estados que não podem ser representados, eficientemente, em um computador clássico. Para extrair informações sobre o estado, um circuito quântico deve ter uma medição que mapeie os resultados (possível aleatório, devido à natureza fundamental dos sistemas quânticos) aos registros clássicos, que assim podem ser eficientemente representados.</p></li>
<li><p><a class="reference internal" href="apidoc/pulse.html#module-qiskit.pulse" title="qiskit.pulse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.pulse</span></code></a> Um cronograma de pulso é um conjunto de pulsos que são enviados para um experimento quântico e que são aplicados em um canal (linha de entrada experimental). Este é um nível inferior ao de circuitos e requer que cada portão no circuito seja representado como um conjunto de pulsos. Neste nível, os experimentos podem ser projetados para reduzir erros (dissociação dinâmica, mitigação de erros e formas de pulso ideais).</p></li>
<li><p><a class="reference internal" href="apidoc/transpiler.html#module-qiskit.transpiler" title="qiskit.transpiler"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.transpiler</span></code></a> Uma grande parte da pesquisa sobre computação quântica está trabalhando em como executar um circuito quântico em dispositivos reais.  Nestes dispositivos, erros experimentais e de coerência introduzem erros, durante o processamento. Assim, para obter uma implementação robusta, é essencial reduzir o número de portões e o tempo de execução geral do circuito quântico. O transpilador introduz o conceito de um gerenciador de passarelas para permitir que os usuários explorem a otimização e encontrem os melhores circuitos quânticos para dado algoritmo. Chamamos de transpilador já que o resultado final ainda é um circuito.</p></li>
<li><p><a class="reference internal" href="apidoc/providers.html#module-qiskit.providers" title="qiskit.providers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.providers</span></code></a> Uma vez que o usuário fez os circuitos para rodar no backend, eles precisam ter uma maneira conveniente de trabalhar com ele. No Terra fazemos isso usando quatro partes:</p>
<ol class="arabic simple">
<li><p>O <code class="docutils literal notranslate"><span class="pre">Provider</span></code> é uma entidade que implementa a classe de base abstrata <a class="reference internal" href="stubs/qiskit.providers.BaseProvider.html#qiskit.providers.BaseProvider" title="qiskit.providers.BaseProvider"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProvider</span></code></a> e fornece acesso a um grupo de diferentes backends (por exemplo, backends disponíveis, através do <a class="reference external" href="https://quantum-computing.ibm.com">IBM Quantum Experience</a>). Ele interage com aqueles backends para, por exemplo, descobrir quais estão disponíveis, ou recuperar uma instância de um backend particular.</p></li>
<li><p>Um <code class="docutils literal notranslate"><span class="pre">Backend</span></code> é uma entidade que implementa uma classe base abstrata <a class="reference internal" href="stubs/qiskit.providers.BaseBackend.html#qiskit.providers.BaseBackend" title="qiskit.providers.BaseBackend"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseBackend</span></code></a>, que representam um simulador ou um computador quântico real, e são responsáveis por executar circuitos quânticos e retornar os resultados. Eles tem um método de execução que utiliza um objeto <cite>qobj</cite> como entrada e retorna um objeto <cite>BaseJob</cite>. Este objeto permite execução assíncrona das tarefas para recuperar os resultados do backend quando a tarefa estiver completa.</p></li>
<li><p>Instâncias <code class="docutils literal notranslate"><span class="pre">Job</span></code> são implementações da classe de base abstrata <a class="reference internal" href="stubs/qiskit.providers.BaseJob.html#qiskit.providers.BaseJob" title="qiskit.providers.BaseJob"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseJob</span></code></a> e podem ser pensadas como o “ticket” para um trabalho enviado. Eles identificam o estado da execução em um determinado ponto no tempo (por exemplo, se o trabalho foi enfileirado, está executando ou tiver falhado) e também permitem o controle sobre o processo.</p></li>
<li><p><a class="reference internal" href="stubs/qiskit.result.Result.html#qiskit.result.Result" title="qiskit.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> Uma vez que o <cite>job</cite> tenha terminado, o Terra permite que os resultados sejam obtidos, a partir dos backends remotos utilizando <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">job.result()</span></code>. Este objeto de resultado contém os dados quânticos e a forma mais comum de interagir com ele é utilizando <code class="docutils literal notranslate"><span class="pre">result.get_counts(circuito)</span></code>. Este método permite que o usuário consiga as contagens brutas do circuito quântico e use-as para mais análises com ferramentas de informação quânticas fornecidas pelo Terra.</p></li>
</ol>
</li>
<li><p><a class="reference internal" href="apidoc/quantum_info.html#module-qiskit.quantum_info" title="qiskit.quantum_info"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.quantum_info</span></code></a> Para executar algoritmos mais avançados e análise dos circuitos executados no computador quântico, é importante ter ferramentas para implementar tarefas simples de informação quântica. Estas incluem métodos para estimar métricas e gerar estados quânticos, operações e canais.</p></li>
<li><p><a class="reference internal" href="apidoc/visualization.html#module-qiskit.visualization" title="qiskit.visualization"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.visualization</span></code></a> Em Terra temos muitas ferramentas para visualizar um circuito quântico. Isto permite uma inspeção rápida do circuito quântico, para ter certeza, de que é o que o usuário queria implementar. Há uma versão em texto, python e látex. Uma vez que o circuito tenha sido executado, é importante ser capaz de visualizar a saída. Há uma função simples (<a class="reference internal" href="stubs/qiskit.visualization.plot_histogram.html#qiskit.visualization.plot_histogram" title="qiskit.visualization.plot_histogram"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_histogram()</span></code></a>) para plotar os resultados de um circuito quântico, incluindo uma versão interativa. Há também uma função <code class="xref py py-func docutils literal notranslate"><span class="pre">plot_state()</span></code> e <code class="xref py py-func docutils literal notranslate"><span class="pre">plot_bloch_vetor()</span></code> que permite a plotagem de um estado quântico.</p></li>
</ol>
</div>
<div class="section" id="aer">
<span id="id2"></span><h2>Aer<a class="headerlink" href="#aer" title="Link permanente para este título">¶</a></h2>
<p>Aer, o elemento ‘ar’, permeia todos os elementos Qiskit. Para realmente acelerar o desenvolvimento de computadores quânticos, precisamos de melhores simuladores, emuladores e depuradores. Aer nos ajuda a entender os limites dos processadores clássicos, demonstrando até que ponto eles podem mimetizar a computação quântica. Além disso, podemos usar o Aer para verificar se os computadores quânticos atuais e, os do futuro próximo, funcionam corretamente. Isso pode ser feito esticando os limites da simulação e simulando os efeitos de ruído realista sobre a computação.</p>
<p>O Aer fornece uma estrutura de simulador de alto desempenho para circuitos quânticos usando a pilha de software Qiskit. Ele contém backends de simulador em C++ otimizados para execução de circuitos compilados no Terra. O Aer também fornece ferramentas para a construção de modelos de ruído, altamente configuráveis, para a realização de simulações ruidosas realistas dos erros, que ocorrem, durante a execução em dispositivos reais.</p>
<p>O Qiskit Aer inclui três backends de simulador de alto desempenho:</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="stubs/qiskit.providers.aer.QasmSimulator.html#qiskit.providers.aer.QasmSimulator" title="qiskit.providers.aer.QasmSimulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QasmSimulator</span></code></a></dt><dd><p>Permite a execução de múltiplos disparos ideais e com ruídos de circuitos qiskit e retorna contagens ou memória. Existem vários métodos que podem ser usados para simular diferentes circuitos de forma mais eficiente. Estes incluem:</p>
<ol class="arabic simple">
<li><p><em>statevector</em> - Usa uma simulação de estado densa.</p></li>
<li><p><em>stabilizer</em> - Usa um simulador de estado de estabilização Clifford, que é válido apenas para circuitos Clifford e modelos com ruído.</p></li>
<li><p><em>extended_stabilizer</em> - Usa um simulador próximo, que decompõe circuitos em termos de estado de estabilização, cujo número cresce com o número de portões que não usam Clifford.</p></li>
<li><p><em>matrix_product_state</em> - Usa um simulador de Matriz de Estado do Produto (MPS).</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="stubs/qiskit.providers.aer.StatevectorSimulator.html#qiskit.providers.aer.StatevectorSimulator" title="qiskit.providers.aer.StatevectorSimulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">StatevectorSimulator</span></code></a></dt><dd><p>Permite a execução de captura única ideal de circuitos qiskit e retorna o estado denso final do simulador, após à aplicação.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="stubs/qiskit.providers.aer.UnitarySimulator.html#qiskit.providers.aer.UnitarySimulator" title="qiskit.providers.aer.UnitarySimulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">UnitarySimulator</span></code></a></dt><dd><p>Permite a execução ideal de captura única de circuitos de qiskit e retorna a matriz unitária final do próprio circuito. Note que o circuito não pode conter medidas ou operações de redefinição para este processo interno.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="ignis">
<span id="id3"></span><h2>Ignis<a class="headerlink" href="#ignis" title="Link permanente para este título">¶</a></h2>
<p>Ignis, o elemento ‘fogo’, é dedicado ao combate do ruído e dos erros e ao estabelecimento de um novo caminho. Isso inclui melhor caracterização de erros, melhora nas portas e computação na presença de ruído. Ignis é destinado àqueles que desejam projetar códigos de correção de erros quânticos ou que querem estudar maneiras de caracterizar erros, através de métodos, como a tomografia, ou, até mesmo, encontrar maneiras melhores de utilizar as portas, explorando o desacoplamento dinâmico e o controle ótimo.</p>
<p>O Ignis fornece código para os usuários gerarem, facilmente, circuitos para experimentos específicos, dado um conjunto mínimos de parâmetros de entrada do usuário. O código do Ignis contém três componentes fundamentais:</p>
<dl class="simple">
<dt><strong>Circuitos</strong></dt><dd><p>O módulo de circuitos fornece o código para gerar a lista de circuitos para um determinado experimento do Ignis, com base em um conjunto mínimo de parâmetros do usuário. Estes são, então, executados no Terra ou no Aer.</p>
</dd>
<dt><strong>Fitters</strong></dt><dd><p>Os resultados de um experimento de Ignis são passados para o módulo Fitters onde são analisados e encaixados, de acordo com o modelo físico que descreve o experimento. Os Fitters podem traçar os dados mais ajustados e retornar uma lista de parâmetros.</p>
</dd>
<dt><strong>Filtros</strong></dt><dd><p>Para certos experimentos de Ignis, os fitters podem retornar um objeto Filtro. Filtros podem ser utilizados para mitigar erros em outras experiências, utilizando os resultados de calibração de um experimento Ignis.</p>
</dd>
</dl>
<p>O Qiskit Ignis é organizado em três tipos de experimentos, que podem ser realizados:</p>
<ul class="simple">
<li><p><a class="reference internal" href="apidoc/characterization.html#module-qiskit.ignis.characterization" title="qiskit.ignis.characterization"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.ignis.characterization</span></code></a> Experimentos de caracterização são projetados para medir parâmetros em um sistema do tipo de parâmetros de ruído (T1, T2-star, T2), parâmetros Hamiltonianos, como a taxa de interação ZZ, e erros de controle nos portões.</p></li>
<li><p><a class="reference internal" href="apidoc/verification.html#module-qiskit.ignis.verification" title="qiskit.ignis.verification"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.ignis.verification</span></code></a> Os experimentos de verificação são projetados para verificar o portão e o desempenho inferior do circuito. A verificação inclui estado e processo tomográfico, volume quântico e aferição aleatória (RB). Esses experimentos fornecem informações para determinar métricas de desempenho como a fidelidade do portão.</p></li>
<li><p><a class="reference internal" href="apidoc/mitigation.html#module-qiskit.ignis.mitigation" title="qiskit.ignis.mitigation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.ignis.mitigation</span></code></a> Os experimentos de Mitigation executam circuitos de calibração, que são analisados para gerar rotinas de mitigação, que podem ser aplicadas a conjuntos arbitrários de resultados executados no mesmo backend. O código do ignis gerará uma lista de circuitos, que executam medições de calibração. Os resultados dessas medições serão processados por um Fitter e produzirão um Filter, que pode ser usado para aplicar mitigação a outros resultados.</p></li>
</ul>
</div>
<div class="section" id="aqua">
<span id="id4"></span><h2>Aqua<a class="headerlink" href="#aqua" title="Link permanente para este título">¶</a></h2>
<p>Aqua, o elemento ‘água’, é o elemento da vida. Para fazer a computação quântica corresponder às suas expectativas, precisamos encontrar aplicações do mundo real. Aqua é onde os algoritmos para computadores quânticos são construídos. Esses algoritmos podem ser usados para construir aplicativos para computação quântica. Aqua é acessível a especialistas de domínio em química, otimização, finanças e IA, que querem explorar os benefícios do uso de computadores quânticos como aceleradores para tarefas computacionais específicas.</p>
<p>Problemas que podem se beneficiar do poder da computação quântica foram identificados em inúmeros domínios, como Química, Inteligência Artificial (IA), Otimização e Finanças. A computação quântica, no entanto, requer habilidades muito especializadas. Para atender às necessidades da vasta população de profissionais que desejam utilizar e contribuir para a computação quântica em vários níveis da pilha de software, criamos o Qiskit Aqua.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="development_strategy.html" class="btn btn-neutral float-right" title="Development Strategy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="getting_started.html" class="btn btn-neutral float-left" title="Primeiros passos com Qiskit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Qiskit Development Team
      <span class="lastupdated">
        Última atualização em 2020/09/18.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Você está visualizando</span>
    lang: pt_BR
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>Idiomas</dt>
      
        <dd><a class="version" href="/documentation/the_elements.html">English</a></dd>
      
        <dd><a class="version" href="/documentation/locale/ja_JP/the_elements.html">Japanese</a></dd>
      
        <dd><a class="version" href="/documentation/locale/de_DE/the_elements.html">German</a></dd>
      
        <dd><a class="version" href="/documentation/locale/ko_KR/the_elements.html">Korean</a></dd>
      
    </dl>
    
  </div>
  <script>
    jQuery('.version').click((evt) => {
      const hash = window.location.hash
      const complete_url = evt.target.href + hash
      window.location = complete_url
      evt.preventDefault()
    })
  </script>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>